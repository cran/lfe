#!/usr/bin/perl
$wantse = 0;
$nofe = 0;
$savecomp = 0;
$analyze = 0;
$complim = 0;
$merge = 0;
$collect = 1;
$tol = 0;
$itsbig = 0;
$randkac = 0;
$bN = 0;
$robust = 'FALSE';
$usecg = 'FALSE';
while(<>) {
  chomp($_);
  # strip comments
  s/#.*$//;
  @line = split;
  next if($#line == -1);
  $cmd = shift @line;
  if($cmd eq 'file') {
    $datafile = shift @line;
  } elsif($cmd eq 'vars') {
    @filevars = @line;
  } elsif($cmd eq 'dummy') {
      @dummies = @line;
  } elsif($cmd eq 'response') {
    $resp = shift @line;
  } elsif($cmd eq 'covars') {
    @covars = @line;
  } elsif($cmd eq 'iv') {
      $iv = join(' ',@line);
  } elsif($cmd eq 'robust') {
      $robust = 'TRUE';
  } elsif($cmd eq 'cluster') {
      $clustervar = shift @line;
      $robust = 'TRUE';
  } elsif ($cmd eq 'model') {
      $model = join(' ',@line);
  } elsif($cmd eq 'fe') {
    @fe = @line;
  } elsif($cmd eq 'se') {
      $bN = 0 + shift(@line);
      if($bN == 0) {$bN = 100;}
  } elsif($cmd eq 'out') {
    @outlist = @line;
  } elsif($cmd eq 'randkac') {
      $randkac=1;
  } elsif($cmd eq 'nofe') {
      $nofe = 1;
  } elsif($cmd eq 'savecomp') {
      $savecomp = 1;
  } elsif($cmd eq 'analyze') {
      $analyze = 1;
  } elsif($cmd eq 'merge') {
      $merge = 1;
  } elsif($cmd eq 'complim') {
      $complim = 0+shift(@line);
  } elsif($cmd eq 'splitcomp') {
      $collect = 0;
  } elsif($cmd eq 'se') {
      $wantse = 0; # disabled due to lack of good algorithms
  } elsif($cmd eq 'itsbig') {
      $itsbig = 1;
  } elsif($cmd eq 'usecg') {
      $usecg = 'TRUE';
  } elsif($cmd eq 'tol') {
      $tol = shift(@line);
  } else {
    die "Unknown line starting with $cmd";
  }
}


if($datafile =~ m/\.dta$/i) {
    $format = 'dta';
} elsif ($datafile =~ m/\.rda|\.rdata/i) {
    $format = 'rda';
} else {
    $format = 'csv';
}

# either covars and response must be specified
# or model
if(defined($model)) {
    if(defined(@covars) || defined($resp)) {
	print STDERR "WARNING: model line overrides covars and response \n";
    }
} elsif(!defined(@covars) || !defined($resp)) {
    die "Either both covars and response must be defined, or model\n";
} else {
    $model = $resp . "~" . join('+',@covars);
}

if(defined(@fe)) {
  $model .= '+G('.join(')+G(',@fe).')'
}


# That's it, now, generate R-code
print "#switch off echo for non-interactive runs\n";
print "if(!interactive()) options(echo=FALSE)\n";

print "
dformat = '$format';
# show warnings as they occur
oldopts <- options(warn=1)
version <- packageDescription('lfe',fields='Version')
packdata <- packageDescription('lfe',fields='Packaged')
cat('******* This is the LFE',version,'software at the Frisch Centre
******* estimating linear models with multiple fixed effects.
******* By courtesy of Simen Gaure, 2011.  Have a nice day!\\n\\n')
";
if($tol > 0) {print "options(lfe.eps=$tol)\n";}
print "forcefact <- c()\n";
if($#dummies >=0) {
    print "forcefact <- c('" .join("','",@dummies) . "')\n";
}

print "
require('lfe')
options(lfe.usecg=$usecg)

# read the datafile, with correct types, numeric for covariates,
# character for categories

model <- formula($model)
tm <- terms(model,specials='G')
fefrm <- paste('~',paste(labels(tm)[attr(tm,'specials')\$G-1],collapse='+'))
fvars <- all.vars(parse(text=fefrm))

if(dformat == 'dta') {
    library(foreign)
    cat(date(),'Start reading Stata file','$datafile\\n')
    tab <- read.dta('$datafile',convert.factors=NA)
    cat(date(),nrow(tab),' records read from','$datafile\\n')
} else if(dformat == 'rda') {
    load('$datafile')
} else {

  filevars = c('" . join("','",@filevars) . "')
  #What are their types on input?  
  # fe's should be read as character
  # covars and response as numeric
  # unused as character
  # also, those in array @dummies should be textual
  # so that they're coerced to factor
  # we know the fe's, and response, we must figure out the covars
  # used in model.  It should be parsed in R
  ";
  print "varnames <- all.vars(model)\n";
  if(defined($iv)) {
     print "varnames <- unique(c(varnames,all.vars($iv)))\n";
  }
  print "
  typelist <- vector('list',length(filevars))
  names(typelist) <- filevars
  typelist[names(typelist) %in% varnames]  <- 0
  typelist[names(typelist) %in% forcefact] <- ''
  typelist[fvars] <- ''
  ";
  if(defined($clustervar)) {
    print "  typelist['$clustervar'] <- ''\n";
  }
  print "
  cat(date(),'Start reading from file','$datafile\\n')
  # it takes forever to create a data.frame with a large file
  # we stick to a list() from scan, but we convert the
  # factors manually
  #tab <- data.frame(scan('$datafile',what=typelist))
  tab <- scan('$datafile',what=typelist,multi.line=FALSE)
  # drop those we don't use, @@@@@ what about merging? @@@@@
  tab <- tab[unlist(lapply(typelist,function(t) !is.null(t)))];
  cat(date(),'File read\\n')
}

# convert to factors manually
for( f in forcefact) {
    tab[[f]] <- factor(tab[[f]])
}

if(!inherits(tab,'data.frame')) {
  # fake a data.frame
  #attr(tab,'row.names') <- 1:length(tab[[1]])
  class(tab) <- 'data.frame'
  attr(tab,'row.names') <- NULL
}

festr <- paste('list(',paste(labels(tm)[attr(tm,'specials')\$G-1],collapse=','),')')
factors <- local({G <- as.factor;'*'<-interaction;eval(parse(text=festr),tab,environment())})
nm <- unlist(eval(parse(text=festr),list(G=function(t) as.character(substitute(t)))))
names(factors) <- nm

for(i in seq_along(factors)) {
  cat(date(),'There are',nlevels(factors[[i]]),names(factors)[[i]],'effects\\n')
}

cf <- compfactor(factors)
cat(date(),'There are',nlevels(cf),'connected components\\n')
if(length(factors) > 2) 
  cat(date(),'There are more than 2 dummy-groups, so nobody can help you if the dummies are non-estimable\\n')
cat(date(),'Centering tolerance is',getOption('lfe.eps'),'\\n')
cat(date(),'Centering variables and doing OLS on centered system...\\n\\n')
";
$cvar = '';
if(defined($clustervar)) {
    $cvar = ", clustervar='$clustervar'";
}
if(defined($iv)) {
    print "est <- felm($model,data=tab,iv=$iv$cvar)\n";
#    print "
#  ivmod <- update($model,$ivlhs ~ . - $ivlhs + $ivrhs)
#  cat(date(),'Instrumental eq\\n'); print(ivmod)
#  est1 <- felm(ivmod ,data=tab)
#  print(summary(est1))
#  cat(date(),'Done 1st step on $ivlhs\n')
#  tab[,'$ivlhs.fit'] <- est1\$fitted
#  est <- felm(update($model,. ~ . -$ivlhs + $ivlhs.fit),data=tab)
#  ";
    
} else {
  print "est <- felm($model,data=tab$cvar)\n";
}
if(defined($iv)) {
print "
cat('First step estimation:\\n')
print(summary(est\$ivz,robust=$robust$cvar))
cat('Second step estimation:\\n')
";
}
print "
print(summary(est,robust=$robust$cvar))

sink('coef.csv')
print(data.frame(value=est\$coefficients, se=est\$se, row.names=names(est\$coefficients)))
sink(NULL)
cat(date(),'Coefficients written to coef.csv\\n')
";
if($savecomp) {
  print "
  fr <- data.frame(comp=cf,factors)
  for(i in seq_along(factors)) {
    tfr <- unique(fr[,c(1,i+1)])
    fn <- paste('comp-',names(factors)[[i]],'.csv',sep='')
    write.table(tfr,file=fn,row.names=FALSE,quote=FALSE)    
    cat(date(),'Components written to file',fn,'\\n')
  }

  ";
}

if($nofe) {
  print "cat(date(),'Fixed effects not requested, finishing\\n')
  options(oldopts)
  if(!interactive()) quit('no')";
  exit;
}

print "cat(date(),'Continuing with finding fixed effects\\n')";

print "

# So, that's it, if we're not interested in finding the
# fixed effects.  But if we are, we must pick up the
# residuals for the full model, i.e. use est to predict
# non-centered Y from non-centered X and find the residuals.

# We can't use predict directly since we've messed around
# with the intercept.  We do it manually

# We need to save some memory by ditching the large parts of est
# (the qr and stuff, keep only what's needed)
est <- est[c('fe','residuals','refnames','full.residuals','cfactor')]
invisible(gc())
class(est) <- NULL
";
if($bN > 0) {
    print "fes <- getfe(est,se=TRUE,bN=$bN)\n";
} else {
    print "fes <- getfe(est)\n";
}
print "
rm(est)
invisible(gc())
cat(date(),'Fixed effects found; just doing some bookkeeping now...\\n')

";

print "

# split the frame into categories
frms <- list()
for(nm in levels(fes[,'fe'])) {

  whch <- which(fes[,'fe'] == nm)
  fr <- fes[whch,]
  fn <- paste('fe-',nm,'.',dformat,sep='')  
  fr[,nm] <- fr[,'idx']
  rownames(fr) <- fr[,nm]
";
if($bN > 0) {
    print "fr <- fr[,c(nm,'effect','se','comp','obs')]\n";
} else {
    print "fr <- fr[,c(nm,'effect','comp','obs')]\n";
}

print "
  if(dformat == 'dta') {
     write.dta(fr,fn,convert.factors='numeric')
  } else {
    write.table(fr,file=fn,quote=FALSE,row.names=FALSE)
  }
  frms[[nm]] <- fr
  cat(date(),'FE written to',fn,'\\n')      
}
";



# note to self.  Check whether package 'plyr' may be used for 
# faster merging.
if($merge) {
 print "
# stuff it back into the dataset

cat(date(),'Doing some more bookkeeping, i.e. merging...\\n')
class(tab) <- 'list'
tab[['comp']] <- cf
for(f in names(frms)) {
   fr <- frms[[f]]
   fact <- tab[[f]]
   effnam <- paste(f,'.eff',sep='')

   tab[[effnam]] <- rep(0,length(fact))
   split(tab[[effnam]],fact) <- fr[,'effect']
#   tab[[effnam]] <- fr[fact,'effect'] 
}
class(tab) <- 'data.frame'

cat(date(),'Writing merged data set to fe-merged.',dformat,'\\n')
rownames(tab) <- 1:length(tab[[1]])
if(dformat == 'dta') {
  write.dta(tab,'fe-merged.dta')
} else {
  write.table(tab,'fe-merged.csv',quote=FALSE,row.names=FALSE)
}
";
}

print "
cat(date(),'Computation done\\n')
options(oldopts)
if(!interactive()) quit('no')
";
